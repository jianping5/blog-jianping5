<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>LRU | Jianping5</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="favicon.jpg">
    <meta name="description" content="最近最少使用算法，主要用于内存淘汰上。比如操作系统、MySQL、Redis 中均有对 LRU 的实现，并为应对相应的问题做了优化。

Linux 操作系统和 MySQL 主要应对预读失效和缓存污染的问题

预读机制

Linux 操作系统为基于 Page Cache 的读缓存机制提供了预读机制，应用程序只想读取磁盘一个 page 的内容，出于空间局部性的原理，操作系统会额外 ...">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/assets/css/0.styles.f8fe1092.css" as="style"><link rel="preload" href="/assets/js/app.c1fa583d.js" as="script"><link rel="preload" href="/assets/js/7.88fc818a.js" as="script"><link rel="preload" href="/assets/js/3.1eee002c.js" as="script"><link rel="preload" href="/assets/js/18.e660c193.js" as="script"><link rel="prefetch" href="/assets/js/10.9d420c0d.js"><link rel="prefetch" href="/assets/js/11.b42294c3.js"><link rel="prefetch" href="/assets/js/12.52d5e8a8.js"><link rel="prefetch" href="/assets/js/13.4170fdfa.js"><link rel="prefetch" href="/assets/js/14.364103c0.js"><link rel="prefetch" href="/assets/js/15.6f2fbfc0.js"><link rel="prefetch" href="/assets/js/16.1a00f02c.js"><link rel="prefetch" href="/assets/js/17.a029641d.js"><link rel="prefetch" href="/assets/js/19.c2e5733e.js"><link rel="prefetch" href="/assets/js/4.ef75d550.js"><link rel="prefetch" href="/assets/js/5.319e6a2e.js"><link rel="prefetch" href="/assets/js/6.cf0169a8.js"><link rel="prefetch" href="/assets/js/8.efbbe776.js"><link rel="prefetch" href="/assets/js/9.e7309807.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.2c0a3311.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f8fe1092.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">Jianping5 </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/post/" class="nav-link router-link-active">Blog</a></li><li class="nav-item"><a href="/about/" class="nav-link">About</a></li><li class="nav-item"><a href="https://github.com/jianping5" target="_blank" rel="noopener noreferrer" class="nav-link external">Github</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">Jianping5 </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/post/" class="nav-link router-link-active">Blog</a></li><li class="mobile-nav-item"><a href="/about/" class="nav-link">About</a></li><li class="mobile-nav-item"><a href="https://github.com/jianping5" target="_blank" rel="noopener noreferrer" class="nav-link external">Github</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        LRU
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">jianping5</span> <span itemprop="address">   in ShangHai</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2023-05-19T00:00:00.000Z">
      Fri May 19 2023
    </time></div> <!----></div></header> <div itemprop="articleBody" class="content__default"><p>最近最少使用算法，主要用于内存淘汰上。比如操作系统、MySQL、Redis 中均有对 LRU 的实现，并为应对相应的问题做了优化。</p> <h3 id="linux-操作系统和-mysql-主要应对预读失效和缓存污染的问题"><a href="#linux-操作系统和-mysql-主要应对预读失效和缓存污染的问题" class="header-anchor">#</a> Linux 操作系统和 MySQL 主要应对预读失效和缓存污染的问题</h3> <h4 id="预读机制"><a href="#预读机制" class="header-anchor">#</a> 预读机制</h4> <ol><li>Linux 操作系统为基于 Page Cache 的读缓存机制提供了预读机制，应用程序只想读取磁盘一个 page 的内容，出于空间局部性的原理，操作系统会额外读取三个 page 的内容到内存中。</li> <li>MySQL Innodb 存储引擎的 Buffer Pool 也有类似的预读机制，MySQL 从磁盘加载页时，会把它相邻的页也加载进来，目的是减少磁盘 I/O。</li></ol> <p><strong>预读失效</strong>：这些被提前加载进来的页，并没有被访问，相当于预读工作白做了。且不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是热点数据，这样就大大降低了缓存命中率。</p> <p><strong>如何避免</strong>：让预读页停留在内存里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，将数据分为冷数据和热数据，分别进行 LRU 算法。</p> <p><strong>如何实现？</strong></p> <ul><li>Linux 操作系统实现了两个 LRU 链表：活跃 LRU 链表和非活跃 LRU 链表。</li> <li>MySQL 的 Innodb 存储引擎在一个 LRU 链表上划分了两个区域，young 区域和 old 区域。</li></ul> <h4 id="缓存污染"><a href="#缓存污染" class="header-anchor">#</a> 缓存污染</h4> <p>在批量读取数据的时候，由于数据被访问了一次，这些大量数据都会被加入到活跃 LRU 链表（或 young 区域），而导致之前存在其中的热点数据被淘汰，且这些大量数据在很长一段时间内都不会被访问的话，那么就导致缓存被污染了。</p> <p><strong>问题</strong>：导致大量热点数据被淘汰，当这些热点数据再次被访问时，缓存未命中，就会产生大量的磁盘 I/O，系统性能就会急剧下降。</p> <p><strong>如何避免</strong>：提高进入到活跃 LRU 链表（或 young 区域）的门槛，就能有效地保证在其内的热点数据不会被轻易替换掉。</p> <p><strong>如何实现？</strong></p> <ul><li>Linux 操作系统，在内存页被访问第二次时，才将页从 inactive list 升级到 active list 里。</li> <li>MySQL Innodb，在内存页被访问第二次时，要对停留在 old 区域里的时间进行判断。
<ul><li>若 Time(access second) - Time(access first) &lt;= 1（默认值），该页就不会升级。</li> <li>若 Time(access second) - Time(access first) &gt; 1，那么该页就会从 old 转为 young。</li></ul></li></ul> <h3 id="redis-主要应对内存占用的问题"><a href="#redis-主要应对内存占用的问题" class="header-anchor">#</a> Redis 主要应对内存占用的问题</h3> <p>Redis 实现一种<strong>近似 LRU 算法</strong>，具体是在 Redis 的对象结构体中添加一个字段，用来记录此数据的最后一次访问时间。</p> <p>当 Redis 进行内存淘汰时，会使用随机采样的方式来淘汰数据，随机选取 5 个值（可配置），然后淘汰最久未使用的那个。</p> <p>为了解决缓存污染的问题，Redis 还实现了 LFU 算法，相比 LRU 算法，多记录了<strong>数据的访问频次</strong>的信息。</p> <p>Redis 对象结构中添加了 24 bits 的 lru 字段，用来记录对象的访问信息，LFU 算法中，高 16bit 存储 ldt(Last Decrement Time)，低 8bit 存储 logc(Logistic Counter)。</p> <blockquote><ul><li>ldt: 记录 key 的访问时间戳\</li> <li>logc: 记录 key 的访问频次，它的值越小表示使用频率越低，越容易淘汰。</li></ul></blockquote> <h3 id="lru-k"><a href="#lru-k" class="header-anchor">#</a> LRU-K</h3> <p>LRU-K 算法多维护了一个队列，用来记录所有缓存数据被访问的历史（可以按照 FIFO、LRU、LFU 算法进行淘汰），只有当数据访问的次数达到 K 时，才将数据放入真正的缓存队列。（通常是 LRU-2）</p> <p>Two-queues 算法，类似于 LRU-2，只不过有两条缓存队列（FIFO 队列和 LRU 队列）</p> <ol><li>数据第一次访问，放入 FIFO 队列中</li> <li>若 FIFO 队列已满，则淘汰队头元素</li> <li>若 FIFO 队列中的元素被再次访问，则将其从 FIFO 队列中移除，添加到缓存队列队头</li> <li>若缓存队列中的元素被再次访问，则将其添加到队头</li> <li>若 LRU 队列已满，则淘汰队尾元素（最久未访问元素）</li></ol> <hr> <h3 id="java-实现-lru-算法"><a href="#java-实现-lru-算法" class="header-anchor">#</a> java 实现 LRU 算法</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>

    <span class="token comment">// 创建双向链表中的节点</span>
    <span class="token keyword">class</span> <span class="token class-name">DLinkedNode</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> key<span class="token punctuation">;</span>
        <span class="token keyword">int</span> value<span class="token punctuation">;</span>
        <span class="token class-name">DLinkedNode</span> next<span class="token punctuation">;</span>
        <span class="token class-name">DLinkedNode</span> prev<span class="token punctuation">;</span>
        <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 维护一个 hash 表，key 为关键字，value 为节点</span>
    <span class="token comment">// 通过缓存数据的键映射到其在双向链表中的位置</span>
    <span class="token keyword">private</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 创建伪节点：头节点和尾节点</span>
    <span class="token class-name">DLinkedNode</span> head<span class="token punctuation">;</span>
    <span class="token class-name">DLinkedNode</span> tail<span class="token punctuation">;</span>
    
    <span class="token comment">// 容量</span>
    <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>
    
    <span class="token comment">// 双向链表大小</span>
    <span class="token keyword">int</span> size<span class="token punctuation">;</span>

    <span class="token comment">// LRUCache 类的构造函数</span>
    <span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>
        head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>
        tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 根据 key 值从缓存中获取对应节点，分两种情况：</span>
    <span class="token comment">// 1. 若 key 不存在，则返回 -1</span>
    <span class="token comment">// 2. 若 key 存在，则先将当前节点删除，然后再将当前节点移到双向链表的头部（表示最近访问的节点）</span>
    <span class="token comment">// 返回该节点的值</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">DLinkedNode</span> node <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">moveToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 添加 k-v 到缓存中，分两种情况</span>
    <span class="token comment">// 1. 若 key 不存在，则创建新节点，并将该新节点添加到双向链表头部，size++</span>
    <span class="token comment">// 判断当前 size 是否大于 capacity</span>
    <span class="token comment">// 1.1 若大于，则移除双向链表尾部元素（即最近最不常访问的节点），size--</span>
    <span class="token comment">// 1.2 若不大于，则不做操作</span>
    <span class="token comment">// 2. 若 key 存在，则更新对应节点的 value，又由于当前访问了该节点</span>
    <span class="token comment">// 所以需要将当前节点移到连双向链表头部（具体做法是：删除当前节点，再将当前节点添加到头部）</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">DLinkedNode</span> node <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">DLinkedNode</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">moveToHead</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
            size<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">removeTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                size<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            node<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">moveToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 将指定节点添加到链表头部</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">moveToHead</span><span class="token punctuation">(</span><span class="token class-name">DLinkedNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>
        head<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 删除尾部节点，注意维护的哈希表中也需要删除对应节点</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tail<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        tail<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>
        tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> tail<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 删除指定节点（用于删除该节点在被访问前所在的位置的节点）</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token class-name">DLinkedNode</span> node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><hr> <h3 id="go-实现-lru-算法"><a href="#go-实现-lru-算法" class="header-anchor">#</a> Go 实现 LRU 算法</h3> <div class="language-Go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> lru

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">&quot;container/list&quot;</span>
<span class="token punctuation">)</span>

<span class="token comment">// LRU cache. It is not safe for concurrent access.</span>
<span class="token keyword">type</span> Cache <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    maxBytes    <span class="token builtin">int64</span>
    nbytes      <span class="token builtin">int64</span>
    ll          <span class="token operator">*</span>list<span class="token punctuation">.</span>List
    cache       <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>list<span class="token punctuation">.</span>Element
    <span class="token comment">// optional and executed when an entry is purges</span>
    OnEvicted <span class="token keyword">func</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">,</span> value Value<span class="token punctuation">)</span>     
<span class="token punctuation">}</span>

<span class="token keyword">type</span> entry <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    key     <span class="token builtin">string</span>
    value   Value
<span class="token punctuation">}</span>

<span class="token comment">// Value use Len to count how many bytes it takes</span>
<span class="token keyword">type</span> Value <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token comment">// New is the Constructor of Cache</span>
<span class="token keyword">func</span> <span class="token function">New</span><span class="token punctuation">(</span>maxBytes <span class="token builtin">int64</span><span class="token punctuation">,</span> onEvicted <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> Value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span>Cache <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>Cache<span class="token punctuation">{</span>
        maxBytes<span class="token punctuation">:</span> maxBytes<span class="token punctuation">,</span>
        ll<span class="token punctuation">:</span> list<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        cache<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>list<span class="token punctuation">.</span>Element<span class="token punctuation">)</span><span class="token punctuation">,</span>
        OnEvicted<span class="token punctuation">:</span> onEvicted<span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Get look ups a Key's value</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Cache<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>value Value<span class="token punctuation">,</span> ok <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> ele<span class="token punctuation">,</span> ok <span class="token operator">:=</span> c<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
        c<span class="token punctuation">.</span>ll<span class="token punctuation">.</span><span class="token function">MoveToFront</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span>
        <span class="token comment">// 此处为泛型转换（Value 的类型为 any）</span>
        kv <span class="token operator">:=</span> ele<span class="token punctuation">.</span>Value<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>entry<span class="token punctuation">)</span>
        <span class="token keyword">return</span> kv<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>

<span class="token comment">// RemoveOldest: removes the oldest item</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Cache<span class="token punctuation">)</span> <span class="token function">RemoveOldest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ele <span class="token operator">:=</span> c<span class="token punctuation">.</span>ll<span class="token punctuation">.</span><span class="token function">Back</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> ele <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
        c<span class="token punctuation">.</span>ll<span class="token punctuation">.</span><span class="token function">Remove</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span>
        kv <span class="token operator">:=</span> ele<span class="token punctuation">.</span>Value<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>entry<span class="token punctuation">)</span>
        <span class="token function">delete</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>cache<span class="token punctuation">,</span> kv<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
        c<span class="token punctuation">.</span>nbytes <span class="token operator">-=</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>kv<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">int64</span><span class="token punctuation">(</span>kv<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> c<span class="token punctuation">.</span>OnEvicted <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
            c<span class="token punctuation">.</span><span class="token function">OnEvicted</span><span class="token punctuation">(</span>kv<span class="token punctuation">.</span>key<span class="token punctuation">,</span> kv<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Add: adds a value to the cache</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Cache<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>key <span class="token builtin">string</span><span class="token punctuation">,</span> value Value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> ele<span class="token punctuation">,</span> ok <span class="token operator">:=</span> c<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
        c<span class="token punctuation">.</span>ll<span class="token punctuation">.</span><span class="token function">MoveToFront</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span>
        kv <span class="token operator">:=</span> ele<span class="token punctuation">.</span>Value<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>entry<span class="token punctuation">)</span>
        c<span class="token punctuation">.</span>nbytes <span class="token operator">+=</span> <span class="token function">int64</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">int64</span><span class="token punctuation">(</span>kv<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        kv<span class="token punctuation">.</span>value <span class="token operator">=</span> value
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        ele <span class="token operator">:=</span> c<span class="token punctuation">.</span>ll<span class="token punctuation">.</span><span class="token function">PushFront</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>entry<span class="token punctuation">{</span>key<span class="token punctuation">,</span> value<span class="token punctuation">}</span><span class="token punctuation">)</span>
        c<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> ele
        c<span class="token punctuation">.</span>nbytes <span class="token operator">+=</span> <span class="token function">int64</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">int64</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">Len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">for</span> c<span class="token punctuation">.</span>maxBytes <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> c<span class="token punctuation">.</span>maxBytes <span class="token operator">&lt;</span> c<span class="token punctuation">.</span>nbytes <span class="token punctuation">{</span>
        c<span class="token punctuation">.</span><span class="token function">RemoveOldest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h3 active"><a href="#linux-操作系统和-mysql-主要应对预读失效和缓存污染的问题" title="Linux 操作系统和 MySQL 主要应对预读失效和缓存污染的问题">Linux 操作系统和 MySQL 主要应对预读失效和缓存污染的问题</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#redis-主要应对内存占用的问题" title="Redis 主要应对内存占用的问题">Redis 主要应对内存占用的问题</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#lru-k" title="LRU-K">LRU-K</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#java-实现-lru-算法" title="java 实现 LRU 算法">java 实现 LRU 算法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#go-实现-lru-算法" title="Go 实现 LRU 算法">Go 实现 LRU 算法</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8><li class="contact-item" data-v-3d9deeb8><a href="https://github.com/jianping5" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-3d9deeb8><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-3d9deeb8></path></svg>
          
        </a></li><li class="contact-item" data-v-3d9deeb8><a href="mailto:jianping756@gmail.com" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-mail" data-v-3d9deeb8><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z" data-v-3d9deeb8></path><polyline points="22,6 12,13 2,6" data-v-3d9deeb8></polyline></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8><li class="copyright-item" data-v-3d9deeb8>jianping5 © 2019</li></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.c1fa583d.js" defer></script><script src="/assets/js/7.88fc818a.js" defer></script><script src="/assets/js/3.1eee002c.js" defer></script><script src="/assets/js/18.e660c193.js" defer></script>
  </body>
</html>
